/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export type TokenBalanceStruct = {
  tokenAddres: PromiseOrValue<string>;
  balance: PromiseOrValue<BigNumberish>;
};

export type TokenBalanceStructOutput = [string, BigNumber] & {
  tokenAddres: string;
  balance: BigNumber;
};

export type DecimalStruct = {
  value: PromiseOrValue<BigNumberish>;
  decimals: PromiseOrValue<BigNumberish>;
};

export type DecimalStructOutput = [BigNumber, number] & {
  value: BigNumber;
  decimals: number;
};

export type PoolStateStruct = {
  paused: PromiseOrValue<boolean>;
  balances: TokenBalanceStruct[];
  totalLPSupply: TokenBalanceStruct;
  ampFactor: DecimalStruct;
  lpFee: DecimalStruct;
  governanceFee: DecimalStruct;
};

export type PoolStateStructOutput = [
  boolean,
  TokenBalanceStructOutput[],
  TokenBalanceStructOutput,
  DecimalStructOutput,
  DecimalStructOutput,
  DecimalStructOutput
] & {
  paused: boolean;
  balances: TokenBalanceStructOutput[];
  totalLPSupply: TokenBalanceStructOutput;
  ampFactor: DecimalStructOutput;
  lpFee: DecimalStructOutput;
  governanceFee: DecimalStructOutput;
};

export interface PoolInterface extends utils.Interface {
  functions: {
    "add(uint256[],uint256)": FunctionFragment;
    "adjustAmpFactor(uint32,uint32)": FunctionFragment;
    "ampInitialTimestamp()": FunctionFragment;
    "ampTargetTimestamp()": FunctionFragment;
    "changeGovernanceFeeRecipient(address)": FunctionFragment;
    "getMarginalPrices()": FunctionFragment;
    "getState()": FunctionFragment;
    "governance()": FunctionFragment;
    "governanceFee()": FunctionFragment;
    "governanceFeeRecipient()": FunctionFragment;
    "initialize(string,string,address,int8,address[],int8[],uint32,uint32,uint32,address,address)": FunctionFragment;
    "lpTokenData()": FunctionFragment;
    "paused()": FunctionFragment;
    "poolTokensData(uint256)": FunctionFragment;
    "proxiableUUID()": FunctionFragment;
    "removeExactBurn(uint256,uint8,uint256)": FunctionFragment;
    "removeExactOutput(uint256[],uint256)": FunctionFragment;
    "removeUniform(uint256,uint256[])": FunctionFragment;
    "setFees(uint32,uint32)": FunctionFragment;
    "setPaused(bool)": FunctionFragment;
    "swap(uint256,uint8,uint8,uint256)": FunctionFragment;
    "swapExactInput(uint256[],uint8,uint256)": FunctionFragment;
    "swapExactOutput(uint256,uint8,uint256[])": FunctionFragment;
    "tokenCount()": FunctionFragment;
    "totalFee()": FunctionFragment;
    "transferGovernance(address)": FunctionFragment;
    "upgradeLpToken(address,bytes)": FunctionFragment;
    "upgradeLpToken(address)": FunctionFragment;
    "upgradeTo(address)": FunctionFragment;
    "upgradeToAndCall(address,bytes)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "add"
      | "adjustAmpFactor"
      | "ampInitialTimestamp"
      | "ampTargetTimestamp"
      | "changeGovernanceFeeRecipient"
      | "getMarginalPrices"
      | "getState"
      | "governance"
      | "governanceFee"
      | "governanceFeeRecipient"
      | "initialize"
      | "lpTokenData"
      | "paused"
      | "poolTokensData"
      | "proxiableUUID"
      | "removeExactBurn"
      | "removeExactOutput"
      | "removeUniform"
      | "setFees"
      | "setPaused"
      | "swap"
      | "swapExactInput"
      | "swapExactOutput"
      | "tokenCount"
      | "totalFee"
      | "transferGovernance"
      | "upgradeLpToken(address,bytes)"
      | "upgradeLpToken(address)"
      | "upgradeTo"
      | "upgradeToAndCall"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "add",
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "adjustAmpFactor",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "ampInitialTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ampTargetTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "changeGovernanceFeeRecipient",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getMarginalPrices",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getState", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "governance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "governanceFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "governanceFeeRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "lpTokenData",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "poolTokensData",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "removeExactBurn",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "removeExactOutput",
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeUniform",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setFees",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPaused",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "swap",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactInput",
    values: [
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactOutput",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenCount",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "totalFee", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "transferGovernance",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeLpToken(address,bytes)",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeLpToken(address)",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;

  decodeFunctionResult(functionFragment: "add", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "adjustAmpFactor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ampInitialTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ampTargetTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeGovernanceFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMarginalPrices",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getState", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "governance", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "governanceFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "governanceFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lpTokenData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "poolTokensData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeExactBurn",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeExactOutput",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeUniform",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setFees", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setPaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "swapExactInput",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactOutput",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "tokenCount", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "totalFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferGovernance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeLpToken(address,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeLpToken(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;

  events: {
    "AdminChanged(address,address)": EventFragment;
    "BeaconUpgraded(address)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "Upgraded(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BeaconUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface BeaconUpgradedEventObject {
  beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<
  [string],
  BeaconUpgradedEventObject
>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface Pool extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PoolInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    add(
      inputAmounts: PromiseOrValue<BigNumberish>[],
      minimumMintAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    adjustAmpFactor(
      targetValue: PromiseOrValue<BigNumberish>,
      targetTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    ampInitialTimestamp(overrides?: CallOverrides): Promise<[number]>;

    ampTargetTimestamp(overrides?: CallOverrides): Promise<[number]>;

    changeGovernanceFeeRecipient(
      _governanceFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getMarginalPrices(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    getState(overrides?: CallOverrides): Promise<[PoolStateStructOutput]>;

    governance(overrides?: CallOverrides): Promise<[string]>;

    governanceFee(overrides?: CallOverrides): Promise<[number]>;

    governanceFeeRecipient(overrides?: CallOverrides): Promise<[string]>;

    initialize(
      lpTokenName: PromiseOrValue<string>,
      lpTokenSymbol: PromiseOrValue<string>,
      lpTokenAddress: PromiseOrValue<string>,
      lpTokenEqualizer: PromiseOrValue<BigNumberish>,
      poolTokenAddresses: PromiseOrValue<string>[],
      poolTokenEqualizers: PromiseOrValue<BigNumberish>[],
      ampFactor: PromiseOrValue<BigNumberish>,
      lpFee: PromiseOrValue<BigNumberish>,
      _governanceFee: PromiseOrValue<BigNumberish>,
      _governance: PromiseOrValue<string>,
      _governanceFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    lpTokenData(
      overrides?: CallOverrides
    ): Promise<[string, number] & { addr: string; equalizer: number }>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    poolTokensData(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string, number] & { addr: string; equalizer: number }>;

    proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

    removeExactBurn(
      burnAmount: PromiseOrValue<BigNumberish>,
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeExactOutput(
      outputAmounts: PromiseOrValue<BigNumberish>[],
      maximumBurnAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeUniform(
      burnAmount: PromiseOrValue<BigNumberish>,
      minimumOutputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFees(
      lpFee: PromiseOrValue<BigNumberish>,
      _governanceFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPaused(
      _paused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swap(
      inputAmount: PromiseOrValue<BigNumberish>,
      inputTokenIndex: PromiseOrValue<BigNumberish>,
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapExactInput(
      inputAmounts: PromiseOrValue<BigNumberish>[],
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapExactOutput(
      maximumInputAmount: PromiseOrValue<BigNumberish>,
      inputTokenIndex: PromiseOrValue<BigNumberish>,
      outputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    tokenCount(overrides?: CallOverrides): Promise<[number]>;

    totalFee(overrides?: CallOverrides): Promise<[number]>;

    transferGovernance(
      _governance: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "upgradeLpToken(address,bytes)"(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "upgradeLpToken(address)"(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  add(
    inputAmounts: PromiseOrValue<BigNumberish>[],
    minimumMintAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  adjustAmpFactor(
    targetValue: PromiseOrValue<BigNumberish>,
    targetTimestamp: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  ampInitialTimestamp(overrides?: CallOverrides): Promise<number>;

  ampTargetTimestamp(overrides?: CallOverrides): Promise<number>;

  changeGovernanceFeeRecipient(
    _governanceFeeRecipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getMarginalPrices(overrides?: CallOverrides): Promise<BigNumber[]>;

  getState(overrides?: CallOverrides): Promise<PoolStateStructOutput>;

  governance(overrides?: CallOverrides): Promise<string>;

  governanceFee(overrides?: CallOverrides): Promise<number>;

  governanceFeeRecipient(overrides?: CallOverrides): Promise<string>;

  initialize(
    lpTokenName: PromiseOrValue<string>,
    lpTokenSymbol: PromiseOrValue<string>,
    lpTokenAddress: PromiseOrValue<string>,
    lpTokenEqualizer: PromiseOrValue<BigNumberish>,
    poolTokenAddresses: PromiseOrValue<string>[],
    poolTokenEqualizers: PromiseOrValue<BigNumberish>[],
    ampFactor: PromiseOrValue<BigNumberish>,
    lpFee: PromiseOrValue<BigNumberish>,
    _governanceFee: PromiseOrValue<BigNumberish>,
    _governance: PromiseOrValue<string>,
    _governanceFeeRecipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  lpTokenData(
    overrides?: CallOverrides
  ): Promise<[string, number] & { addr: string; equalizer: number }>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  poolTokensData(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[string, number] & { addr: string; equalizer: number }>;

  proxiableUUID(overrides?: CallOverrides): Promise<string>;

  removeExactBurn(
    burnAmount: PromiseOrValue<BigNumberish>,
    outputTokenIndex: PromiseOrValue<BigNumberish>,
    minimumOutputAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeExactOutput(
    outputAmounts: PromiseOrValue<BigNumberish>[],
    maximumBurnAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeUniform(
    burnAmount: PromiseOrValue<BigNumberish>,
    minimumOutputAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFees(
    lpFee: PromiseOrValue<BigNumberish>,
    _governanceFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPaused(
    _paused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swap(
    inputAmount: PromiseOrValue<BigNumberish>,
    inputTokenIndex: PromiseOrValue<BigNumberish>,
    outputTokenIndex: PromiseOrValue<BigNumberish>,
    minimumOutputAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapExactInput(
    inputAmounts: PromiseOrValue<BigNumberish>[],
    outputTokenIndex: PromiseOrValue<BigNumberish>,
    minimumOutputAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapExactOutput(
    maximumInputAmount: PromiseOrValue<BigNumberish>,
    inputTokenIndex: PromiseOrValue<BigNumberish>,
    outputAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  tokenCount(overrides?: CallOverrides): Promise<number>;

  totalFee(overrides?: CallOverrides): Promise<number>;

  transferGovernance(
    _governance: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "upgradeLpToken(address,bytes)"(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "upgradeLpToken(address)"(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    add(
      inputAmounts: PromiseOrValue<BigNumberish>[],
      minimumMintAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    adjustAmpFactor(
      targetValue: PromiseOrValue<BigNumberish>,
      targetTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    ampInitialTimestamp(overrides?: CallOverrides): Promise<number>;

    ampTargetTimestamp(overrides?: CallOverrides): Promise<number>;

    changeGovernanceFeeRecipient(
      _governanceFeeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    getMarginalPrices(overrides?: CallOverrides): Promise<BigNumber[]>;

    getState(overrides?: CallOverrides): Promise<PoolStateStructOutput>;

    governance(overrides?: CallOverrides): Promise<string>;

    governanceFee(overrides?: CallOverrides): Promise<number>;

    governanceFeeRecipient(overrides?: CallOverrides): Promise<string>;

    initialize(
      lpTokenName: PromiseOrValue<string>,
      lpTokenSymbol: PromiseOrValue<string>,
      lpTokenAddress: PromiseOrValue<string>,
      lpTokenEqualizer: PromiseOrValue<BigNumberish>,
      poolTokenAddresses: PromiseOrValue<string>[],
      poolTokenEqualizers: PromiseOrValue<BigNumberish>[],
      ampFactor: PromiseOrValue<BigNumberish>,
      lpFee: PromiseOrValue<BigNumberish>,
      _governanceFee: PromiseOrValue<BigNumberish>,
      _governance: PromiseOrValue<string>,
      _governanceFeeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    lpTokenData(
      overrides?: CallOverrides
    ): Promise<[string, number] & { addr: string; equalizer: number }>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    poolTokensData(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string, number] & { addr: string; equalizer: number }>;

    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    removeExactBurn(
      burnAmount: PromiseOrValue<BigNumberish>,
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeExactOutput(
      outputAmounts: PromiseOrValue<BigNumberish>[],
      maximumBurnAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeUniform(
      burnAmount: PromiseOrValue<BigNumberish>,
      minimumOutputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    setFees(
      lpFee: PromiseOrValue<BigNumberish>,
      _governanceFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPaused(
      _paused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    swap(
      inputAmount: PromiseOrValue<BigNumberish>,
      inputTokenIndex: PromiseOrValue<BigNumberish>,
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    swapExactInput(
      inputAmounts: PromiseOrValue<BigNumberish>[],
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    swapExactOutput(
      maximumInputAmount: PromiseOrValue<BigNumberish>,
      inputTokenIndex: PromiseOrValue<BigNumberish>,
      outputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenCount(overrides?: CallOverrides): Promise<number>;

    totalFee(overrides?: CallOverrides): Promise<number>;

    transferGovernance(
      _governance: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    "upgradeLpToken(address,bytes)"(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    "upgradeLpToken(address)"(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AdminChanged(address,address)"(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    "BeaconUpgraded(address)"(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "Upgraded(address)"(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
    Upgraded(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
  };

  estimateGas: {
    add(
      inputAmounts: PromiseOrValue<BigNumberish>[],
      minimumMintAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    adjustAmpFactor(
      targetValue: PromiseOrValue<BigNumberish>,
      targetTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    ampInitialTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    ampTargetTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    changeGovernanceFeeRecipient(
      _governanceFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getMarginalPrices(overrides?: CallOverrides): Promise<BigNumber>;

    getState(overrides?: CallOverrides): Promise<BigNumber>;

    governance(overrides?: CallOverrides): Promise<BigNumber>;

    governanceFee(overrides?: CallOverrides): Promise<BigNumber>;

    governanceFeeRecipient(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      lpTokenName: PromiseOrValue<string>,
      lpTokenSymbol: PromiseOrValue<string>,
      lpTokenAddress: PromiseOrValue<string>,
      lpTokenEqualizer: PromiseOrValue<BigNumberish>,
      poolTokenAddresses: PromiseOrValue<string>[],
      poolTokenEqualizers: PromiseOrValue<BigNumberish>[],
      ampFactor: PromiseOrValue<BigNumberish>,
      lpFee: PromiseOrValue<BigNumberish>,
      _governanceFee: PromiseOrValue<BigNumberish>,
      _governance: PromiseOrValue<string>,
      _governanceFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    lpTokenData(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    poolTokensData(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

    removeExactBurn(
      burnAmount: PromiseOrValue<BigNumberish>,
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeExactOutput(
      outputAmounts: PromiseOrValue<BigNumberish>[],
      maximumBurnAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeUniform(
      burnAmount: PromiseOrValue<BigNumberish>,
      minimumOutputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFees(
      lpFee: PromiseOrValue<BigNumberish>,
      _governanceFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPaused(
      _paused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swap(
      inputAmount: PromiseOrValue<BigNumberish>,
      inputTokenIndex: PromiseOrValue<BigNumberish>,
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapExactInput(
      inputAmounts: PromiseOrValue<BigNumberish>[],
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapExactOutput(
      maximumInputAmount: PromiseOrValue<BigNumberish>,
      inputTokenIndex: PromiseOrValue<BigNumberish>,
      outputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    tokenCount(overrides?: CallOverrides): Promise<BigNumber>;

    totalFee(overrides?: CallOverrides): Promise<BigNumber>;

    transferGovernance(
      _governance: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "upgradeLpToken(address,bytes)"(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "upgradeLpToken(address)"(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    add(
      inputAmounts: PromiseOrValue<BigNumberish>[],
      minimumMintAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    adjustAmpFactor(
      targetValue: PromiseOrValue<BigNumberish>,
      targetTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    ampInitialTimestamp(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    ampTargetTimestamp(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    changeGovernanceFeeRecipient(
      _governanceFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getMarginalPrices(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governanceFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governanceFeeRecipient(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      lpTokenName: PromiseOrValue<string>,
      lpTokenSymbol: PromiseOrValue<string>,
      lpTokenAddress: PromiseOrValue<string>,
      lpTokenEqualizer: PromiseOrValue<BigNumberish>,
      poolTokenAddresses: PromiseOrValue<string>[],
      poolTokenEqualizers: PromiseOrValue<BigNumberish>[],
      ampFactor: PromiseOrValue<BigNumberish>,
      lpFee: PromiseOrValue<BigNumberish>,
      _governanceFee: PromiseOrValue<BigNumberish>,
      _governance: PromiseOrValue<string>,
      _governanceFeeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    lpTokenData(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolTokensData(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    removeExactBurn(
      burnAmount: PromiseOrValue<BigNumberish>,
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeExactOutput(
      outputAmounts: PromiseOrValue<BigNumberish>[],
      maximumBurnAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeUniform(
      burnAmount: PromiseOrValue<BigNumberish>,
      minimumOutputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFees(
      lpFee: PromiseOrValue<BigNumberish>,
      _governanceFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPaused(
      _paused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swap(
      inputAmount: PromiseOrValue<BigNumberish>,
      inputTokenIndex: PromiseOrValue<BigNumberish>,
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapExactInput(
      inputAmounts: PromiseOrValue<BigNumberish>[],
      outputTokenIndex: PromiseOrValue<BigNumberish>,
      minimumOutputAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapExactOutput(
      maximumInputAmount: PromiseOrValue<BigNumberish>,
      inputTokenIndex: PromiseOrValue<BigNumberish>,
      outputAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    tokenCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferGovernance(
      _governance: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "upgradeLpToken(address,bytes)"(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "upgradeLpToken(address)"(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
