import { Keypair, PublicKey, TransactionInstruction, Connection, Signer } from "@solana/web3.js";
import { Timestamp, Decimal } from "./common";
import { PoolState, MutableStateData } from "./poolState";
export declare class PoolInstructor {
    readonly connection: Connection;
    readonly payer: Signer;
    readonly stateKey: PublicKey;
    readonly authority: PublicKey;
    readonly lpMintKey: PublicKey;
    readonly governanceKey: PublicKey;
    readonly governanceFeeKey: PublicKey;
    readonly lpMintDecimals: number;
    readonly tokenMintKeys: readonly PublicKey[];
    readonly tokenDecimals: readonly number[];
    readonly tokenKeys: readonly PublicKey[];
    readonly programId: PublicKey;
    constructor(connection: Connection, payer: Signer, stateKey: PublicKey, authority: PublicKey, lpMintKey: PublicKey, governanceKey: PublicKey, governanceFeeKey: PublicKey, lpMintDecimals: number, tokenMintKeys: readonly PublicKey[], tokenDecimals: readonly number[], tokenKeys: readonly PublicKey[]);
    static fromPoolState(connection: Connection, payer: Signer, poolState: PoolState): Promise<PoolInstructor>;
    static deployPool(connection: Connection, payer: Signer, mintKeys: readonly PublicKey[], governanceKey: PublicKey, lpMintDecimals: number, ampFactor: Decimal, lpFee: Decimal, governanceFee: Decimal, statePair?: Keypair, lpMintPair?: Keypair): Promise<PoolInstructor>;
    static fromStateKey(connection: Connection, payer: Signer, stateKey: PublicKey): Promise<PoolInstructor>;
    get tokenCount(): number;
    getState(): Promise<MutableStateData>;
    createAddIx(inputAmounts: readonly Decimal[], minimumMintAmount: Decimal, userTokenKeys: readonly PublicKey[], userDelegate: PublicKey, userLpKey: PublicKey): TransactionInstruction;
    createRemoveUniformIx(exactBurnAmount: Decimal, minimumOutputAmounts: readonly Decimal[], userTokenKeys: readonly PublicKey[], userDelegate: PublicKey, userLpKey: PublicKey): TransactionInstruction;
    createRemoveExactBurnIx(exactBurnAmount: Decimal, outputTokenIndex: number, minimumOutputAmount: Decimal, userTokenKeys: readonly PublicKey[], userDelegate: PublicKey, userLpKey: PublicKey): TransactionInstruction;
    createRemoveExactOutputIx(maximumBurnAmount: Decimal, exactOutputAmounts: readonly Decimal[], userTokenKeys: readonly PublicKey[], userDelegate: PublicKey, userLpKey: PublicKey): TransactionInstruction;
    createSwapIx(exactInputAmounts: readonly Decimal[], outputTokenIndex: number, minimumOutputAmount: Decimal, userTokenKeys: readonly PublicKey[], userDelegate: PublicKey): TransactionInstruction;
    createApproveLpIx(amount: Decimal, userLpKey: PublicKey, userDelegate: PublicKey, owner: PublicKey): TransactionInstruction;
    createApproveTokenIxs(amounts: readonly Decimal[], userTokenKeys: readonly PublicKey[], userDelegate: PublicKey, owner: PublicKey): readonly TransactionInstruction[];
    createPrepareFeeChangeIx(lpFee: Decimal, governanceFee: Decimal): TransactionInstruction;
    createEnactFeeChangeIx(): TransactionInstruction;
    createPrepareGovernanceTransitionIx(upcomingGovernanceKey: PublicKey): TransactionInstruction;
    createEnactGovernanceTransitionIx(): TransactionInstruction;
    createChangeGovernanceFeeAccountIx(governanceFeeKey: PublicKey): TransactionInstruction;
    createAdjustAmpFactorIx(targetTs: Timestamp, targetValue: Decimal): TransactionInstruction;
    createSetPauseIx(paused: boolean): TransactionInstruction;
    add(inputAmounts: readonly Decimal[], minimumMintAmount: Decimal, userTokenKeys: readonly PublicKey[], userLpKey: PublicKey, payer: Signer): Promise<void>;
    removeUniform(exactBurnAmount: Decimal, minimumOutputAmounts: readonly Decimal[], userTokenKeys: readonly PublicKey[], userLpKey: PublicKey, payer: Signer): Promise<void>;
    removeExactBurn(exactBurnAmount: Decimal, outputTokenIndex: number, minimumOutputAmount: Decimal, userTokenKeys: readonly PublicKey[], userLpKey: PublicKey, payer: Signer): Promise<void>;
    removeExactOutput(maximumBurnAmount: Decimal, exactOutputAmounts: readonly Decimal[], userTokenKeys: readonly PublicKey[], userLpKey: PublicKey, payer: Signer): Promise<void>;
    swap(exactInputAmounts: readonly Decimal[], outputTokenIndex: number, minimumOutputAmount: Decimal, userTokenKeys: readonly PublicKey[], payer: Signer): Promise<void>;
    prepareFeeChange(lpFee: Decimal, governanceFee: Decimal, payer: Signer, governance: Signer): Promise<void>;
    enactFeeChange(payer: Signer, governance: Signer): Promise<void>;
    prepareGovernanceTransition(upcomingGovernanceKey: PublicKey, payer: Signer, governance: Signer): Promise<void>;
    enactGovernanceTransition(payer: Signer, governance: Signer): Promise<void>;
    changeGovernanceFeeAccount(governanceFeeKey: PublicKey, payer: Signer, governance: Signer): Promise<void>;
    adjustAmpFactor(targetTs: Timestamp, targetValue: Decimal, payer: Signer, governance: Signer): Promise<void>;
    setPause(paused: boolean, payer: Signer, governance: Signer): Promise<void>;
    sendGovernanceIx(govIx: TransactionInstruction, payer: Signer, governance: Signer): Promise<void>;
    private createDefiIx;
    private createGovernanceIx;
    private createTxIx;
    private toTokenValue;
    private throwOnInvalidTokenIndex;
    private throwIfNotEqualTokenCount;
}
